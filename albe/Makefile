# Copyright (c) 2013 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# GNU Makefile based on shared rules provided by the Native Client SDK.
# See README.Makefiles for more details.

NACL_SDK_ROOT ?= $(abspath $(CURDIR)/../sdk)

VALID_TOOLCHAINS := glibc

TARGET = albe

include $(NACL_SDK_ROOT)/tools/common.mk


# Always use cmd.exe as the shell on Windows!
# Otherwise Make may try to search the path for sh.exe.
# If it is found in a path with a space, the command will fail.
ifeq ($(OS),Windows_NT)
    SHELL := cmd.exe
endif


# Disable DOS PATH warning when using Cygwin based tools Windows
CYGWIN ?= nodosfilewarning
export CYGWIN


DEPS = nacl_io ppapi_cpp
LIBS = nacl_io ppapi_cpp ppapi dl pthread


albe_CFLAGS = -Wall
albe_SOURCES = albe.cc


## Build rules generated by macros from common.mk:
#c_utils_CFLAGS = -Wall
#c_utils_SOURCES = utils/albe_c_utils.cc

# Build rules generated by macros from common.mk:
unarch_CFLAGS = -Wall
unarch_SOURCES = unarch.cc

# Build rules generated by macros from common.mk:
dumb_CFLAGS = -Wall
dumb_SOURCES = dumb.cc


# Build rules generated by macros from common.mk:
$(foreach dep,$(DEPS),$(eval $(call DEPEND_RULE,$(dep))))
$(foreach src,$(albe_SOURCES),$(eval $(call COMPILE_RULE,$(src),$(albe_CFLAGS))))
#$(foreach src,$(c_utils_SOURCES),$(eval $(call COMPILE_RULE,$(src),$(c_utils_CFLAGS))))
$(foreach src,$(unarch_SOURCES),$(eval $(call COMPILE_RULE,$(src),$(unarch_CFLAGS))))
$(foreach src,$(dumb_SOURCES),$(eval $(call COMPILE_RULE,$(src),$(dumb_CFLAGS))))


# The PNaCl workflow uses both an unstripped and finalized/stripped binary.
# On NaCl, only produce a stripped binary for Release configs (not Debug).
ifneq (,$(or $(findstring pnacl,$(TOOLCHAIN)),$(findstring Release,$(CONFIG))))
$(eval $(call LINK_RULE,albe_unstripped,$(albe_SOURCES),$(LIBS),$(DEPS)))
$(eval $(call STRIP_RULE,albe,albe_unstripped))
else
$(eval $(call LINK_RULE,albe,$(albe_SOURCES),$(LIBS),$(DEPS)))
endif

#$(eval $(call SO_RULE,c_utils,$(c_utils_SOURCES)))
$(eval $(call SO_RULE,unarch,$(unarch_SOURCES)))
$(eval $(call SO_RULE,dumb,$(dumb_SOURCES),,,1))

$(eval $(call NMF_RULE,$(TARGET),))
